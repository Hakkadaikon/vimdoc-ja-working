*usr_52.txt*	For Vim バージョン 9.0.  Last change: 2022 Jun 04

		     VIM USER MANUAL - by Bram Moolenaar

			巨大なプラグインを作る


プラグインが単純なこと以上のことを行うと、大きくなる傾向があります。このファイ
ルは、それらが高速に読み込まれるようにする方法と、それらを小さなパーツに分割す
る方法を説明しています。

|52.1|	エクスポートとインポート
|52.2|	オートロード
|52.3|	インポート/エクスポートなしのオートロード
|52.4|	使用する他のメカニズム
|52.5|	旧来のスクリプトから Vim9 script を使う

次章: |usr_90.txt|  Vim のインストール
前章: |usr_51.txt|  プラグインを作る
目次: |usr_toc.txt|

==============================================================================
*52.1*	エクスポートとインポート

Vim9 script は大きな Vim script を容易に書けるようにデザインされています。他の
スクリプト言語、特に TypeScript のようになっています。また、処理内の関数はコン
パイルされ素早く実行できます。これにより Vim9 script はとても速く、最大100倍に
なります。

基本的な考え方は、スクリプトファイルには、スクリプトファイル内でのみ使用される
プライベートな項目と、それらをインポートするスクリプトで使用できるエクスポート
される項目があるということです。これにより、何がどこで定義されているかが非常に
明確になります。

1つの関数をエクスポートし、1つのプライベート関数を持つスクリプトの例から始めま
しょう: >

	vim9script

	export def GetMessage(count: string): string
	   var nr = str2nr(count)
	   var result = $'To {nr} we say '
	   result ..= GetReply(nr)
	   return result
	enddef

	def GetReply(nr: number): string
	  if nr == 42
	     return 'yes'
	  elseif nr = 22
	     return 'maybe'
	  else
	     return 'no'
	  endif
	enddef

`export` は |Vim9| script でのみ動くので `vim9script` コマンドが必要です。

`export def GetMessage(...` の行は `export` から始まっていて、この関数が他のス
クリプトから呼び出すことができることを意味します。`def GetReply(...` の行は
`export` で始まっておらず、これはスクリプトローカル関数であり、このスクリプト
ファイル内でのみ使用できます。

次にインポートされるスクリプトについて説明します。この例の中ではこの配置を使用
しており、これは "pack" ディレクトリ下のプラグインに適しています:
	.../plugin/theplugin.vim
	.../lib/getmessage.vim

"..." ディレクトリが 'runtimepathd' に追加されていると仮定すると、Vim は
"plugin" ディレクトリとソース "theplugin.vim" 内でプラグインを探します。Vim は
"lib" ディレクトリを認識しません、そこに任意のスクリプトを置くことができます。

上のスクリプトは lib/getmessage.vim 内にある GetMessage() をエクスポートしま
す。GetMessage() 関数は plugin/theplugin.vim 内にて使用されます: >

	vim9script

	import "../lib/getmessage.vim"
	command -nargs=1 ShowMessage echomsg getmessage.GetMessage(<f-args>)

`import` コマンドは "../" で始まる相対パスを使用しています。これは、1つ上のディ
レクトリに移動することを意味します。他の種類のパスについては、`:import` コマン
ドを参照してください。

プラグインが提供するコマンドを試す方法: >
	ShowMessage 1
<	To 1 we say no ~
>
	ShowMessage 22
<	To 22 we say maybe ~

関数 GetMessage() には、インポートしたスクリプト名 "getmessage" がプリフィック
スとして付けられていることに注意してください。こうすることで、使用されるすべて
のインポートされた関数について、それがどのスクリプトからインポートされたかが分
かります。複数のスクリプトをインポートする場合、それぞれで GetMessage() 関数を
定義できます: >

	vim9script

	import "../lib/getmessage.vim"
	import "../lib/getother.vim"
	command -nargs=1 ShowMessage echomsg getmessage.GetMessage(<f-args>)
	command -nargs=1 ShowOther echomsg getother.GetMessage(<f-args>)

インポートしたスクリプトの名前が長いあるいは色々な箇所で使う場合、引数に "as"
を追加するとことで短くできます: >
	import "../lib/getmessage.vim" as msg
	command -nargs=1 ShowMessage echomsg msg.GetMessage(<f-args>)


☆再読み込み

覚えておくべき1つのこと: インポートされた "lib/getmessage.vim" スクリプトは1
度だけ読み込まれます。インポート済みで2度目に読み込む時はスキップされ、項目は
最初に作成された以降そのままです。これはインポートコマンドが他のスクリプトであ
るか、再読み込みした同じスクリプト内であるかは関係ありません。

これはプラグインを使用する場合は効率的ですが、プラグインを開発中の場合は、イン
ポート後に "lib/getmessage.vim" を変更しても効果がありません。Vim を終了し、再
起動する必要があります。(理論的根拠: スクリプトで定義された項目は、コンパイル
された関数で使用できます。スクリプトを再度読み込むと、これらの関数が壊れる可能
性があります)。


☆グローバルの利用

どこでも利用可能な、グローバル変数や関数を使用したい場合がときどきあります。プ
ラグインの設定をグローバル変数で渡したい場合などが良い例です。他のスクリプトが
同じ名前を使用するのを阻止するため、他でも使っていたらとても不運ですが、プリ
フィックスを使います。例として、"mytags" プラグインであるなら、このように使用
ます: >

	g:mytags_location = '$HOME/project'
	g:mytags_style = 'fast'

==============================================================================
*52.2*	オートロード

あなたの巨大なスクリプトを部分に分割した後も、全行がスクリプト実行時にロードと
実行されるのは維持されます。各 `import` は要素の定義がされた箇所を検索しそのイ
ンポート済みスクリプトをロードします。これはエラーが早急に見付かるけれども、時
間もかかります。この機能をよく使うのでなければ役に立ちません。

代わりに `import` で必要になるまで遅延させその時にスクリプトを即時にロードする
手段を持ちます。上の例を使い、plugin/theplugin.vim スクリプト内を1箇所だけ変更
してしています: >
	import autoload "../lib/getmessage.vim"

スクリプトの残りの部分は何も変更する必要はありません。 ただし、型はチェックさ
れません。既存の GetMessage() 関数と同等ではなく、使用されるまでチェックされま
せん。スクリプトでより重要なのかを決定する必要があります: 高速な初期化か早期に
エラーが分るか。また、全部がうまく動くかチェックした後に、 "autoload" 引数を後
で追加することもできます。


☆オートロード ディレクトリ

もう1つの形式は絶対パスでも相対パスでもないスクリプト名で autoload を使用する
ことです: >
	import autload "monthlib.vim"

これはスクリプト "monthlib.vim" を 'runtimepath' のオートロード ディレクトリの
中から検索します。Unix ではディレクトリの1つとして "~/.vim/autoload" がよくあ
ります。

この方法の主要な利点として、このスクリプトを他のスクリプトと共有するのが容易で
あることです。Vim が 'runtimepath' 内の "autoload" ディレクトリから検索するた
め、スクリプト名は一意である必要があり、プラグインはいくつかのプラグインマネー
ジャーとともに利用される場合では、'runtimepath' にディレクトリを追加されること
があり、それぞれが  "autoload" ディレクトリを持っているためです。

オートロードなしは: >
	import "monthlib.vim"

Vim は 'runtimepath' のディレクトリ内からスクリプト "monthlib.vim" をインポー
トします。"autoload" の追加や削除する場合はスクリプトが見付かる場所が変わるこ
とに注意してください。位置が相対および絶対のパスであるなら変化はありません。

==============================================================================
*52.3*	インポート/エクスポートなしのオートロード

						*write-library-script*
インポート/エクスポート以前のメカニズムは依然として利用でき一部ユーザーは多少
単純であると感じるかもしれません。それは特別な名前によって関数を呼ぶというアイ
デアです。その関数はオートロードスクリプト内にあります。そのスクリプトのことを
ライブラリスクリプトと呼びます。

オートロードのメカニズムは関数名が "#" 文字を持っているというのが基礎になって
います: >

	mylib#myfunction(arg)

Vim は埋め込まれた "#" 文字によって関数名を認識し、まだ定義がないのであれば
'runtimepath' 内のスクリプト "autoload/mylib.vim" を検索します。そのスクリプト
は "mylib#myfunction()" 関数を定義する必要があります。名前 "mylib" を "#" の前
部分と ".vim" を追加して、スクリプトの名前に使用するというのが一目瞭然です。

mylib.vim スクリプト内に他に多数の関数を置ことができ、ライブラリスクリプト内の
構成が自由です。しかし '#' の前部分がスクリプト名に一致する関数名を使用する必
要があります。そうでないと、Vim はロードするスクリプトが何であるか分らなくなり
ます。この点がインポート/エクスポートメカニズムとの違いになります。

実際に夢中になり多数のライブラリスクリプトを書くのであれば、サブディレクトリを
使用したいでしょう。例: >

	netlib#ftp#read('somefile')

関数名の最後の "#" より上からスクリプト名が取れます。途中にある "#" はスラッ
シュに置き換え、最後の1つは ".vim" にします。つまり、"netlib/ftp.vim" が得られ
ます。Unix の場合、これに使用されるライブラリスクリプトは次のようになります:

	~/.vim/autoload/netlib/ftp.vim

ここで関数の定義はこうなります: >

	def netlib#ftp#read(fname: string)
		#  Read the file fname through ftp
	enddef

関数の名前は呼び出して利用する関数の名前と厳密に同じに定義されていることに注意
しましょう。そして最後の '#' の前部分がサブディレクトリとスクリプト名と厳密に
一致します。

変数にも同じメカニズムが使用できます: >

	var weekdays = dutch#weekdays

これにより スクリプト "autoload/dutch.vim" がロードされ、次のような内容が含ま
れる必要があります: >

	var dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
		\ 'donderdag', 'vrijdag', 'zaterdag']

参考文献: |autoload|。

==============================================================================
*52.4*	使用する他のメカニズム

複数のファイルを使用するのが面倒で、すべてを1つのスクリプトにまとめておくのを
好む人もいます。その結果として起動が遅くなるのを回避するため、小さく一部を定義
し残りを実際に使用するまで遅延するメカニズムがあります。
						*write-plugin-quickload*

基本的なアイデアはプラグインを2回ロードするというものです。初回は機能を呼び出
すユーザーコマンドとマッピングを定義します。2回目では機能を実装している関数を
定義する。

高速ロードがスクリプトの2回ロードを意味するのは意外に思えるかもしません。これ
は初回は素早く、2回目は延期したスクリプトのかたまりのロードを意味し、実際に使
用する時のみ起きます。常に機能を使用のであれば実際のところ遅くなってしまいます!

これには FuncUndefined 自動コマンドを使用します。これは上で説明した |autoload|
の機能とは違った動きです。

如何の例ではどのようにすべきかを示しています: >

	" Vim global plugin for demonstrating quick loading
	" Last Change:	2005 Feb 25
	" Maintainer:	Bram Moolenaar <Bram@vim.org>
	" License:	This file is placed in the public domain.

	if !exists("s:did_load")
		command -nargs=* BNRead  call BufNetRead(<f-args>)
		map <F19> :call BufNetWrite('something')<CR>

		let s:did_load = 1
		exe 'au FuncUndefined BufNet* source ' .. expand('<sfile>')
		finish
	endif

	function BufNetRead(...)
		echo 'BufNetRead(' .. string(a:000) .. ')'
		" read functionality here
	endfunction

	function BufNetWrite(...)
		echo 'BufNetWrite(' .. string(a:000) .. ')'
		" write functionality here
	endfunction

スクリプトの初回ロード時は "s:did_load" は未設定です。"if" と "endif" の間のコ
マンドが実行されます。これは |:finish| コマンドで終わり、残りのスクリプトは実
行されません。

スクリプトの2回目ロード時は "s:did_load" は存在し "endif" 以降のコマンドが実行
されます。これは(長い可能性のある) BufNetRead() と BufNetWrite() 関数を定義し
ます。

あなたのプラグインディレクト内にスクリプトを置くと Vim は初期化時に実行します。
このような流れでイベントが発生します:

1. スクリプトが初期化時にソースされ "BNRead" コマンドが定義され <F19> キーに
   マッピングされます。|FuncUndefined| 自動コマンドが定義されます。":finish"
   コマンドによりスクリプトは早期に終了します。

2. ユーザーが BNRead コマンドをタイプするか <F19> キーを押します。 BufNetRead()
   かBufNetWrite() 関数が呼ばれます。

3. Vim は関数を見付けることができず、|FuncUndefined| 自動コマンドイベントが発
   生します。関数呼び出しが "BufNet*" パターンにマッチしたのなら、コマンドとし
   て "source fname" が実行されます。"fname" はスクリプトの名前に等しく、どこ
   にあるかは問題ないです、なぜなら "<sfile>" を展開して取っているからです
   (|expand()| を参照)。

4. スクリプトは再度ソースされて、"s:did_load" 変数は存在し関数が定義されます。

ロードされた後の関数が |FuncUndefined| 自動コマンドのパターンにマッチすること
に注意してください。他のプラグインで定義するパターンにマッチする関数がないよう
にしないといけません。

==============================================================================
*52.5*	旧来のスクリプトから Vim9 script を使う		*source-vim9-script*

いくつかの場合として持っている旧来の Vim script にて Vim9 script のアイテムを
使いたいことがあります。たとえばあなたの .vimrc がプラグインの初期化をする場合
などです。最良の方法は `:import` を使うことです。例: >

	import 'myNicePlugin.vim'
	call myNicePlugin.NiceInit('today')

これは Vim9 script からエクスポートされた "NiceInit" 関数を見付けそれをスクリ
プトローカルなアイテム "myNicePlugin.NiceInit" として利用可能にします。"s:" を
指定しなくても `:import` は常にスクリプトの名前空間を使います。もし
"myNicePlugin.vim" がすでに読み込み済みであれば再度読み込まれることはありませ
ん。

その上アイテムがグローバルの名前空間に置かれるのを防ぎ (名前の衝突が不測の問題
になり得ます)、そしてたとえ何度もアイテムをインポートしても、スクリプトの読み
込みがただ一度であることを意味します。

いくつかの場合、例えばテストなどで、ただ Vim9 script を読み込みたいだけのこと
があります。大丈夫ですが、グローバルのアイテムだけが利用可能となります。Vim9
script ではこうしたグローバルのアイテムで確実にユニークな名前を使うようにしな
くてはなりません。 例: >
	source ~/.vim/extra/myNicePlugin.vim
	call g:NicePluginTest()

==============================================================================

次章: |usr_90.txt|  Vim のインストール


Copyright: see |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
