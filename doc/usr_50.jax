*usr_50.txt*	For Vim バージョン 9.0.  Last change: 2022 Jun 03

		     VIM USER MANUAL - by Bram Moolenaar

			 高度な Vim script の書き方


|50.1|	例外
|50.2|	可変長引数の関数
|50.3|	ビューの復元

次章: |usr_51.txt|  プラグインを作る
前章: |usr_45.txt|  言語を選択する (ロケール)
目次: |usr_toc.txt|

==============================================================================
*50.1*	例外

まずは例題を見てください: >

	try
	   read ~/templates/pascal.tmpl
	catch /E484:/
	   echo "パスカル用のテンプレートファイルは見つかりませんでした。"
	endtry

`read` コマンドはファイルがなければ失敗します。そのエラーをキャッチして、エラー
メッセージの代わりにより詳細な情報のメッセージを表示しています。

`try` と `endtry` の間で起きたエラーは例外に変わります。例外は文字列です。エ
ラーが例外に変わったとき、文字列にはエラーメッセージが含まれます。また、全ての
エラーメッセージは番号を持っています。例題では "E484:" を含んだエラーをキャッ
チしています。この番号は変わらないことが保証されています (テキストは翻訳される
などして変わるかもしれません)。

素敵なエラーメッセージを出力し、Vim は `:endtry` 以降のコマンドの実行も続けま
す。それ以外のキャッチされないエラーに遭遇した場合、スクリプト/関数/マッピング
の実行は中断されます。

`read` コマンドが他のエラーを起こした場合、"E484:" というパターンはマッチしな
いでしょう。したがって、その例外はキャッチされず、通常のエラーメッセージの表示
とともに実行が中断されます。

次のように書くこともできます: >

	try
	   read ~/templates/pascal.tmpl
	catch
	   echo "パスカル用のテンプレートファイルは見つかりませんでした。"
	endtry

全ての例外がキャッチされます。しかし "E21: Cannot make changes, 'modifiable'
is off" のようなまったく異る問題を示す有効なエラーに気づくことができません。
エラーをキャッチする前によく考えてください!

`finally` という便利なコマンドもあります: >

 	var tmp = tempname()
	try
	   exe ":.,$write " .. tmp
	   exe "!filter " .. tmp
	   :.,$delete
	   exe ":$read " .. tmp
	finally
	   delete(tmp)
	endtry

カーソル行からファイル末尾までを "filter" コマンド (ファイル名を引数に取るコマ
ンド) でフィルタ処理しており、`try` と `finally` の間で問題が起きても、ユーザー
が CTRL-C を押して操作をキャンセルした場合、`call delete(tmp)` は必ず呼ばれま
す。一時ファイルが残ってしまう心配はありません。

`finally` は例外をキャッチせず、エラーはそれ以降の実行を中断します。

例外についてさらに詳しい情報はリファレンスマニュアルの|exception-handling|を
参照してください。

==============================================================================
*50.2*	可変長引数の関数

Vim では可変長個の引数を持つ関数の定義が有効です。これらのコマンドでは、例え
ば、関数が1つの引数(start)を必ず持ちそして最大20個の追加の引数を持つことができ
ます: >

	def Show(start: string, ...items: list<string>)

変数 "items" は関数内のリストとして追加の引数を保持します。任意型のリストのよ
うに使用することができ、例として: >

	def Show(start: string, ...items: list<string>)
	  echohl Title
	  echo "start is " .. start
	  echohl None
	  for index in range(len(items))
	    echon $"  Arg {index} is {items[index]}"
	  endfor
	  echo
	enddef

このように呼び出しできます: >

	Show('Title', 'one', 'two', 'three')
<	start is Title  Arg 0 is one  Arg 1 is two  Arg 2 is three ~

これは `echohl` コマンドを使用しては以降の `echo` コマンドをハイライトするよう
に指定しています。`echohl None` で再度停止します。`echon` コマンドは  `echo`
と同様に動作しますが、出力が改行されません。

引数を1つで呼び出したときは "items" リストは空になります。`range(len(items))`
はインデックス付きのリストを返します。`for` がループするものについては、さらに
詳しく説明します。

==============================================================================
*50.3*	ビューの復元

何らかの変更を加えてから、カーソルのあった場所に戻りたい時があります。そのとき
に、画面に表示されていた行範囲も復元されるとすてきです。

次の例は、現在行をヤンクしてファイルの先頭にプットし、ビューを復元します: >

	map ,p ma"aYHmbgg"aP`bzt`a

これは次のことをしています: >
	ma"aYHmbgg"aP`bzt`a
<	ma			現在のカーソル位置にマーク a を設定
	  "aY			現在行をレジスタ a にヤンク
	     Hmb		ウィンドウの一行目に移動してマーク b を設定
		gg		ファイルの一行目に移動
		  "aP		ヤンクした行をその上にプット
		     `b		ウィンドウの一行目に戻る
		       zt	ウィンドウの表示範囲を以前と同じにする
			 `a	保存しておいたカーソル位置に移動


==============================================================================

Next chapter: |usr_51.txt|  プラグインを作る

Copyright: see |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
